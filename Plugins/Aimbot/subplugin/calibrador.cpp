//---------------------------------------------------------------------------

#pragma hdrstop

#include "calibrador.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)

/*

std::vector<int> angulos;

bool isAnguloDeConvergencia(int angulo, int forca, bool Xflag = false){
	int i,j,k,m,n,r;
	float f, s = 0;

	float power = (float)forca;

	int ultimo = -99;

	for(i = 0; i <= 360; i++){
		int j = i;
		if(Xflag) j = ((i-90+360)%360);

		if(j > angulo) return false;

		s = Sin(j*pi/180);
		f = s * power;
		k = (int)(f);

		if(ultimo != k && (ultimo != -99 || angulo == 0)){
			if(j == angulo)
				return true;
		}

		if(ultimo != k) ultimo = k;
	}

	return false;
}

void __fastcall TShMatrix::calcular(int indice, float t) {
	// VMProtectBegin("calc");
	__try {
		Projetil[indice].x += Projetil[indice].speedX * tick;
		Projetil[indice].y -= Projetil[indice].speedY * tick;
		Projetil[indice].speedX += aceleracaoVentoX * tick;
		Projetil[indice].speedY += aceleracaoVentoY * tick;

		//Projetil[indice].x = x + (aceleracaoVentoX * t + c1);  //Projetil[indice].speedX * tick;// + aceleracaoVentoX * tick * tick * 0.5;
		//Projetil[indice].y = y - (((( (-1 * gravidade) + (efeitoVento * aceleracaoVentoY) ) * t) / efeitoVento) + c2);
		//calculaTornado();

		calculaTornado();

		// }

		// if(flagEspelho){
		// Projetil[indice].x -= (pontoEstatico[indice].x - ultimoPontoEstatico[indice].x);
		// Projetil[indice].y += (pontoEstatico[indice].y - ultimoPontoEstatico[indice].y);
		// }else{
		// Projetil[indice].x += (pontoEstatico[indice].x - ultimoPontoEstatico[indice].x);
		// Projetil[indice].y += (pontoEstatico[indice].y - ultimoPontoEstatico[indice].y);
		// }
	}
	__except (1) {
	}
	// VMProtectEnd();
}

*/
